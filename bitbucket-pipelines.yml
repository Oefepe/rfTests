image: quay.io/centos/centos:stream9

clone:
  depth: full # SonarCloud scanner needs the full history to assign issues properly

definitions:
  caches:
    sonar: ~/.sonar/cache # Caching SonarCloud artifacts will speed up your build
    npm: ~/.npm

  services:
    docker:
      memory: 4096

  steps:
    - step: &build-app-for-gw-staging
        name: Build Image for API Gateway Staging
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'api_gw/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd api_gw
          - GW_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${GW_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $GW_IMAGE
          - echo "GW_IMAGE - ${GW_IMAGE}"

    - step: &deploy-to-gw-staging
        name: Deploy gw to AWS EKS staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'api_gw/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=api-gw
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-backend-staging
        name: Build Image for Backend Staging
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd backend
          - BACKEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - BACKEND_CRON_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT-cron"
          - docker build -f ./Dockerfile.kub -t ${BACKEND_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $BACKEND_IMAGE
          - echo "BACKEND_IMAGE - ${BACKEND_IMAGE}"
          - docker build -f ./Dockerfile.cron -t ${BACKEND_CRON_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $BACKEND_CRON_IMAGE
          - echo "BACKEND_CRON_IMAGE - ${BACKEND_CRON_IMAGE}"

    - step: &deploy-to-backend-staging
        name: Deploy backend to AWS EKS in staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=rfng-backend-service
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &deploy-to-backend-cron-staging
        name: Deploy backend-cron to AWS EKS in staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=rfng-cron
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT-cron"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-notifications-staging
        name: Build Image for Notifications Staging
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/notifications/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd apps/notifications
          - NOTIFICATIONS_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${NOTIFICATIONS_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $NOTIFICATIONS_IMAGE
          - echo "NOTIFICATIONS_IMAGE - ${NOTIFICATIONS_IMAGE}"

    - step: &deploy-to-notifications-staging
        name: Deploy notifiactions to AWS EKS staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/notifications/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=notifications
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-coaching-staging
        name: Build Image for Coaching Staging
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - cd apps/coaching
          - STG_INI_PATH=".env.staging"
          - CURR_TIMESTAMP=$(date "+%y%m%d%H%M")
          # This is an associative bash array, where the key represents a search string,
          # and the value itself represents the replace string.
          - declare -A stg_confs
            stg_confs=(
            [<MYSQL_DB_URL>]=$STG_MYSQL_DB_URL
            )
          # Define the function
          - echo $STG_INI_PATH
          - configurer() {
            for i in "${!stg_confs[@]}"; do
            search=$i
            replace=${stg_confs[$i]}

            sed -i "s^${search}^${replace}^g" $STG_INI_PATH
            ;done
            }
          - configurer
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - COACHING_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${COACHING_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $COACHING_IMAGE
          - echo "COACHING_IMAGE - ${COACHING_IMAGE}"

    - step: &deploy-to-coaching-staging
        name: Deploy coaching to AWS EKS staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=coaching
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-admin-staging
        name: Build Image for admin Staging
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - ADMIN_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:staging-$BITBUCKET_COMMIT"
          - cd apps/admin
          - docker build -f ./Dockerfile -t ${ADMIN_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $ADMIN_IMAGE
          - echo "ADMIN_IMAGE - ${ADMIN_IMAGE}"

    - step: &deploy-to-admin-staging
        name: Deploy admin to AWS EKS staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=admin
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:staging-$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-frontend-staging
        name: Build Image for Frontend Staging
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'frontend/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-staging' ]]; then echo "This can only be performed on aws-staging branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd frontend
          - FRONTEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile.kub -t ${FRONTEND_IMAGE} . --build-arg BUILD_ENV=staging
          - docker push $FRONTEND_IMAGE
          - echo "FRONTEND_IMAGE - ${FRONTEND_IMAGE}"

    - step: &deploy-to-frontend-staging
        name: Deploy frontend to AWS EKS staging
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'frontend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-nonprod
          - export NAMESPACE=duploservices-stage-02
          - export SERVICE_NAME=frontend
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-gw-beta
        name: Build Image for API Gateway Beta
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'api_gw/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd api_gw
          - GW_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${GW_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $GW_IMAGE
          - echo "GW_IMAGE - ${GW_IMAGE}"

    - step: &deploy-to-gw-beta
        name: Deploy gw to AWS EKS in beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'api_gw/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=api-gw
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-backend-beta
        name: Build Image for Backend Beta
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd backend
          - BACKEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile.kub -t ${BACKEND_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $BACKEND_IMAGE
          - echo "BACKEND_IMAGE - ${BACKEND_IMAGE}"

    - step: &deploy-to-backend-beta
        name: Deploy backend to AWS EKS in beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=rfng-backend-service
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-notifications-beta
        name: Build Image for Notifications Beta
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/notifications/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd apps/notifications
          - NOTIFICATIONS_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${NOTIFICATIONS_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $NOTIFICATIONS_IMAGE
          - echo "NOTIFICATIONS_IMAGE - ${NOTIFICATIONS_IMAGE}"

    - step: &deploy-to-notifications-beta
        name: Deploy notifiactions to AWS EKS Beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/notifications/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=notifications
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-coaching-beta
        name: Build Image for Coaching Beta
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - cd apps/coaching
          - BTA_INI_PATH=".env.beta"
          - CURR_TIMESTAMP=$(date "+%y%m%d%H%M")
          # This is an associative bash array, where the key represents a search string,
          # and the value itself represents the replace string.
          - declare -A bta_confs
            bta_confs=(
            [<MYSQL_DB_URL>]=$BTA_MYSQL_DB_URL
            )
          # Define the function
          - echo $BTA_INI_PATH
          - configurer() {
            for i in "${!bta_confs[@]}"; do
            search=$i
            replace=${bta_confs[$i]}

            sed -i "s^${search}^${replace}^g" $BTA_INI_PATH
            ;done
            }
          - configurer
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - COACHING_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${COACHING_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $COACHING_IMAGE
          - echo "COACHING_IMAGE - ${COACHING_IMAGE}"

    - step: &deploy-to-coaching-beta
        name: Deploy coaching to AWS EKS beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=coaching
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-admin-beta
        name: Build Image for admin Beta
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - ADMIN_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:beta-$BITBUCKET_COMMIT"
          - cd apps/admin
          - docker build -f ./Dockerfile -t ${ADMIN_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $ADMIN_IMAGE
          - echo "ADMIN_IMAGE - ${ADMIN_IMAGE}"

    - step: &deploy-to-admin-beta
        name: Deploy admin to AWS EKS beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=admin
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:beta-$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-frontend-beta
        name: Build Image for Frontend Beta
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'frontend/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-beta' ]]; then echo "This can only be performed on aws-beta branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd frontend
          - FRONTEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile.kub -t ${FRONTEND_IMAGE} . --build-arg BUILD_ENV=beta
          - docker push $FRONTEND_IMAGE
          - echo "FRONTEND_IMAGE - ${FRONTEND_IMAGE}"

    - step: &deploy-to-frontend-beta
        name: Deploy frontend to AWS EKS in beta
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'frontend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-beta01
          - export SERVICE_NAME=frontend
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-gw-production
        name: Build Image for API Gateway Production
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd api_gw
          - GW_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${GW_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $GW_IMAGE
          - echo "GW_IMAGE - ${GW_IMAGE}"

    - step: &deploy-to-gw-production
        name: Deploy gw to AWS EKS in production
        services:
          - docker
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=api-gw
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/api_gw:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-notifications-production
        name: Build Image for Notifications Production
        services:
          - docker
        caches:
          - docker
          - pip
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd apps/notifications
          - NOTIFICATIONS_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${NOTIFICATIONS_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $NOTIFICATIONS_IMAGE
          - echo "NOTIFICATIONS_IMAGE - ${NOTIFICATIONS_IMAGE}"

    - step: &deploy-to-notifications-production
        name: Deploy notifiactions to AWS EKS Production
        services:
          - docker
        script:
          - echo "Deploying notification service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=notifications
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/notifications:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-coaching-production
        name: Build Image for Coaching Production
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - cd apps/coaching
          - PROD_INI_PATH=".env.production"
          - CURR_TIMESTAMP=$(date "+%y%m%d%H%M")
          # This is an associative bash array, where the key represents a search string,
          # and the value itself represents the replace string.
          - declare -A prod_confs
            prod_confs=(
            [<MYSQL_DB_URL>]=$PROD_MYSQL_DB_URL
            )
          # Define the function
          - echo $PROD_INI_PATH
          - configurer() {
            for i in "${!prod_confs[@]}"; do
            search=$i
            replace=${prod_confs[$i]}

            sed -i "s^${search}^${replace}^g" $PROD_INI_PATH
            ;done
            }
          - configurer
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - COACHING_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile -t ${COACHING_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $COACHING_IMAGE
          - echo "COACHING_IMAGE - ${COACHING_IMAGE}"

    - step: &deploy-to-coaching-production
        name: Deploy coaching to AWS EKS production
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/coaching/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=coaching
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/coaching:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-admin-production
        name: Build Image for admin Production
        services:
          - docker
        caches:
          - docker
          - pip
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - ADMIN_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:prod-$BITBUCKET_COMMIT"
          - cd apps/admin
          - docker build -f ./Dockerfile -t ${ADMIN_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $ADMIN_IMAGE
          - echo "ADMIN_IMAGE - ${ADMIN_IMAGE}"

    - step: &deploy-to-admin-production
        name: Deploy admin to AWS EKS production
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'apps/admin/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=admin
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/admin:prod-$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-backend-production
        name: Build Image for Backend production
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - cd backend
          - PROD_INI_PATH=".env.production"
          - CURR_TIMESTAMP=$(date "+%y%m%d%H%M")
          # This is an associative bash array, where the key represents a search string,
          # and the value itself represents the replace string.
          - declare -A prod_confs
            prod_confs=(
            [<MAILGUN_API_APIKEY>]=$PROD_MAILGUN_API_APIKEY
            )
          # Define the function
          - echo $PROD_INI_PATH
          - configurer() {
            for i in "${!prod_confs[@]}"; do
            search=$i
            replace=${prod_confs[$i]}

            sed -i "s^${search}^${replace}^g" $PROD_INI_PATH
            ;done
            }
          - configurer
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - BACKEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - BACKEND_CRON_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT-cron"
          - docker build -f ./Dockerfile.kub -t ${BACKEND_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $BACKEND_IMAGE
          - echo "BACKEND_IMAGE - ${BACKEND_IMAGE}"
          - docker build -f ./Dockerfile.cron -t ${BACKEND_CRON_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $BACKEND_CRON_IMAGE
          - echo "BACKEND_CRON_IMAGE - ${BACKEND_CRON_IMAGE}"

    - step: &deploy-to-backend-production
        name: Deploy backend to AWS EKS in production
        services:
          - docker
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=rfng-backend-service
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &deploy-to-backend-cron-production
        name: Deploy backend-cron to AWS EKS in production
        services:
          - docker
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=rfng-cron
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/backend:$BITBUCKET_COMMIT-cron"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-app-for-frontend-production
        name: Build Image for Frontend production
        services:
          - docker
        size: 2x
        caches:
          - docker
          - pip
        script:
          - if [[ $BITBUCKET_BRANCH != 'aws-production' ]]; then echo "This can only be performed on aws-production branch" && exit 1; fi
          - yum update -y
          - yum install -y epel-release jq
          - yum install -y python3-pip
          - python3 -m pip install docutils
          - python3 -m pip install awscli
          - aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 755359203481.dkr.ecr.us-west-2.amazonaws.com
          - cd frontend
          - FRONTEND_IMAGE="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - docker build -f ./Dockerfile.kub -t ${FRONTEND_IMAGE} . --build-arg BUILD_ENV=production
          - docker push $FRONTEND_IMAGE
          - echo "FRONTEND_IMAGE - ${FRONTEND_IMAGE}"

    - step: &deploy-to-frontend-production
        name: Deploy frontend to AWS EKS in production
        services:
          - docker
        script:
          - echo "Deploying service to AWS EKS"
          - echo "Installing AWS CLI and kubectl"
          - yum install -y unzip
          - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          - unzip awscliv2.zip
          - ./aws/install
          - curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          - chmod +x ./kubectl
          - mv ./kubectl /usr/local/bin/kubectl
          - echo "Switching to EKS-specific IAM user credentials"
          - export AWS_ACCESS_KEY_ID=$EKS_AWS_ACCESS_KEY_ID
          - export AWS_SECRET_ACCESS_KEY=$EKS_AWS_SECRET_ACCESS_KEY
          - export AWS_DEFAULT_REGION=us-west-2
          - export CLUSTER_NAME=duploinfra-prod01
          - export NAMESPACE=duploservices-prod01
          - export SERVICE_NAME=frontend
          - export IMAGE_URL="755359203481.dkr.ecr.us-west-2.amazonaws.com/frontend:$BITBUCKET_COMMIT"
          - aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION
          - kubectl set image deployment/$SERVICE_NAME $SERVICE_NAME=$IMAGE_URL --namespace $NAMESPACE
          - kubectl rollout status deployment/$SERVICE_NAME --namespace=$NAMESPACE

    - step: &build-test-sonarcloud-backend
        name: Build, test and analyze backend on SonarCloud
        image:
          name: node:18-alpine
        caches:
          - node
          - sonar
        condition:
          changesets:
            includePaths:
              - 'backend/**'
        script:
          - cd backend
          - apk add curl
          - node ../auditPackages.mjs "Backend"
          - curl --proxy 'http://localhost:29418' --request PUT "http://api.bitbucket.org/2.0/repositories/$BITBUCKET_REPO_OWNER/$BITBUCKET_REPO_SLUG/commit/$BITBUCKET_COMMIT/reports/mySystem-backend-001" --data '@reports/auditedPackages.json' -H 'Content-Type:application/json'
          - npm ci --quiet
          - npm install -g nyc
          - npm run test:unit:coverage
          - pipe: sonarsource/sonarcloud-scan:2.0.0
            variables:
              SONAR_TOKEN: ${SONAR_BACKEND}
              EXTRA_ARGS: '-Dsonar.projectKey=rapidfunnel_RFNG_backend -Dsonar.organization=rapidfunnel -Dsonar.sources=src' # -Dsonar.typescript.lcov.reportPaths=coverage/lcov.info'
          - pipe: sonarsource/sonarcloud-quality-gate:0.1.6
            variables:
              SONAR_TOKEN: ${SONAR_BACKEND}
    - step: &build-test-sonarcloud-frontend
        name: Build, test and analyze frontend on SonarCloud
        image:
          name: node:18-alpine
        caches:
          - node
          - sonar
        condition:
          changesets:
            includePaths:
              - 'frontend/**'
        script:
          # When two same pipelines are running there are some issues with permissions, so we remove the pipes folder
          - rm -rf /opt/atlassian/pipelines/agent/build/.bitbucket/pipelines/generated/pipeline/pipes
          - cd frontend
          - apk add curl
          - node ../auditPackages.mjs "Frontend"
          - curl --proxy 'http://localhost:29418' --request PUT "http://api.bitbucket.org/2.0/repositories/$BITBUCKET_REPO_OWNER/$BITBUCKET_REPO_SLUG/commit/$BITBUCKET_COMMIT/reports/mySystem-frontend-001" --data '@reports/auditedPackages.json' -H 'Content-Type:application/json'
          # Temporary disabled due to the issue with the tests
          # - npm ci --quiet
          # - npm run test
          - pipe: sonarsource/sonarcloud-scan:2.0.0
            variables:
              SONAR_TOKEN: ${SONAR_FRONTEND}
              EXTRA_ARGS: '-Dsonar.projectKey=rapidfunnel_RFNG_frontend -Dsonar.organization=rapidfunnel -Dsonar.sources=src' # -Dsonar.typescript.lcov.reportPaths=coverage/lcov.info'
          - pipe: sonarsource/sonarcloud-quality-gate:0.1.6
            variables:
              SONAR_TOKEN: ${SONAR_FRONTEND}

options:
  docker: true
  size: 2x

pipelines:
  branches:
    aws-staging:
      - parallel:
          - step: *build-app-for-gw-staging
          - step: *build-app-for-backend-staging
          - step: *build-app-for-frontend-staging
          - step: *build-app-for-notifications-staging
          - step: *build-app-for-coaching-staging
          - step: *build-app-for-admin-staging
      - step: *deploy-to-gw-staging
        dependencies:
          - build-app-for-gw-staging
      - step: *deploy-to-notifications-staging
        dependencies:
          - build-app-for-notifications-staging
      - step: *deploy-to-backend-staging
        dependencies:
          - build-app-for-backend-staging
      - step: *deploy-to-backend-cron-staging
        dependencies:
          - build-app-for-backend-staging
      - step: *deploy-to-frontend-staging
        dependencies:
          - build-app-for-frontend-staging
      - step: *deploy-to-coaching-staging
        dependencies:
          - build-app-for-coaching-staging
      - step: *deploy-to-admin-staging
        dependencies:
          - build-app-for-admin-staging

    aws-beta:
      - parallel:
          - step: *build-app-for-gw-beta
          - step: *build-app-for-backend-beta
          - step: *build-app-for-frontend-beta
          - step: *build-app-for-notifications-beta
          - step: *build-app-for-coaching-beta
          - step: *build-app-for-admin-beta
      - step: *deploy-to-gw-beta
        dependencies:
          - build-app-for-gw-beta
      - step: *deploy-to-notifications-beta
        dependencies:
          - build-app-for-notifications-beta
      - step: *deploy-to-backend-beta
        dependencies:
          - build-app-for-backend-beta
      - step: *deploy-to-frontend-beta
        dependencies:
          - build-app-for-frontend-beta
      - step: *deploy-to-coaching-beta
        dependencies:
          - build-app-for-coaching-beta
      - step: *deploy-to-admin-beta
        dependencies:
          - build-app-for-admin-beta

    aws-production:
      - parallel:
          - step: *build-app-for-gw-production
          - step: *build-app-for-backend-production
          - step: *build-app-for-frontend-production
          - step: *build-app-for-notifications-production
          - step: *build-app-for-coaching-production
          - step: *build-app-for-admin-production
      - step: *deploy-to-gw-production
        dependencies:
          - build-app-for-gw-production
      - step: *deploy-to-notifications-production
        dependencies:
          - build-app-for-notifications-production
      - step: *deploy-to-backend-production
        dependencies:
          - build-app-for-backend-production
      - step: *deploy-to-frontend-production
        dependencies:
          - build-app-for-frontend-production
      - step: *deploy-to-coaching-production
        dependencies:
          - build-app-for-coaching-production
      - step: *deploy-to-admin-production
        dependencies:
          - build-app-for-admin-production

  pull-requests:
    '**':
      - step: *build-test-sonarcloud-backend
      - step: *build-test-sonarcloud-frontend
